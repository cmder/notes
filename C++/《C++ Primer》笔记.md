## 前言

2011年，C++标准委员会发布了ISO C++标准的一个重要修订版。

现代C++语言可以看作是三部分组成的：

- 低级语言，大部分继承自C语言。

- 现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。

-  标准库，它利用高级特性来提供有用的数据结构和算法。

对于包含C++语言基础内容的章节，**我们用一个小人正在读书的图标加以标记。**用这个图标标记的那些章节，涵盖了构成语言核心部分的主题。**每个人都应该阅读并理解这些章节的内容。**

**对于那些涉及高级主题或特殊目的主题的章节，我们也进行了标记。在首次阅读时，这些章节可以跳过或快速浏览。 我们用一叠书的图标标记这些章节，**指出在这些地方，你可以放心地放下书本。快速浏览这些章节可能是一个好主意，这样你就可以知道有这些特性存在。但在真正需要在自己的程序中使用这些特性之前，没有必要花费时间仔细学习这些主题。

为了进一步引导读者的注意力，我们还用**放大镜图标标记**了特别复杂的概念。我们希望读者对有这种标记的章节能**多花费一些时间**彻底理解其中的内容。

在第I部分和第II部分中介绍了C++语言和标准库的基础内容

本书的第III部分和第IV部分介绍了如何编写类的形式的抽象类型。第III部分包含基础内容，第IV部分介绍更专门的语言特性。

## 第1章 开始

![epub_33692196_5](https://res.weread.qq.com/wrepub/epub_33692196_5)

一个函数的定义包含四部分：返回类型（return type）、函数名（functionname）、一个括号包围的形参列表（parameter list，允许为空）以及函数体（function body）。

后缀告诉系统这个文件是一个C++程序。不同编译器使用不同的后缀命名约定，最常见的包括.cc、.cxx、.cpp、.cp及.C。

**编译和运行**：

从命令行运行编译器：$ CC prog1.cc

其中，CC是编译器程序的名字，$是系统提示符。编译器生成一个可执行文件。**Windows系统会将这个可执行文件命名为prog1.exe。 ** **UNIX系统中的编译器通常将可执行文件命名为a.out。**

**为了在Windows系统中运行一个可执行文件**，我们需要提供可执行文件的文件名，可以忽略其扩展名.exe：$ prog1

在一些系统中，即使文件就在当前目录或文件夹中，你也必须显式指出文件的位置。在此情况下，我们可以键入$ .\prog1 “.”后跟一个反斜线指出该文件在当前目录中。

**为了在UNIX系统中运行一个可执行文件**，我们需要使用全文件名，包括文件扩展名：$ a.out如果需要指定文件位置，需要用一个“.”后跟一个斜线来指出可执行文件位于当前目录中。$ ./a.out

在不同操作和编译器系统中，运行C++编译器的命令也各不相同。最常用的编译器是GNU编译器和微软Visual Studio编译器。默认情况下，运行GNU编译器的命令是g++：![epub_33692196_8](https://res.weread.qq.com/wrepub/epub_33692196_8)

$是系统提示符。-o prog1是编译器参数，指定了可执行文件的文件名。

在UNIX系统中，可执行文件没有后缀；在Windows系统中，后缀为.exe。**如果省略了-o prog1参数，在UNIX系统中编译器会生成一个名为a.out的可执行文件**，在Windows系统中则会生成一个名为a.exe的可执行文件（注意：根据使用的GNU编译器的版本，你可能需要指定-std=c++0x参数来打开对C++11的支持）。

运行微软Visual Studio 2010编译器的命令为cl：![epub_33692196_9](https://res.weread.qq.com/wrepub/epub_33692196_9)

命令cl调用编译器，/EHsc是编译器选项，用来打开标准异常处理。微软编译器会自动生成一个可执行文件，其名字与第一个源文件名对应。可执行文件的文件名与源文件名相同，后缀为.exe。在此例中，可执行文件的文件名为prog1.exe。

### 1.2 初识输入输出

C++语言并未定义任何输入输出（IO）语句，取而代之，包含了一个全面的标准库（standard library）来提供IO机制（以及很多其他设施）。

iostream库包含两个基础类型istream和ostream，分别表示输入流和输出流。

一个流就是一个字符序列，是从IO设备读出或写入IO设备的。

标准库定义了4个**IO对象**。**cin cout cerr clog**

为了处理输入，我们使用一个名为cin（发音为see-in）的istream类型的对象。这个对象也被称为标准输入（standard input）。

每个使用标准库设施的程序都必须包含相关的头文件。

main的函数体的第一条语句执行了一个**表达式**（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了输出运算符（<<）在标准输出上打印消息：![img](https://res.weread.qq.com/wrepub/epub_33692196_12)

<<运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即，计算结果就是我们写入给定值的那个ostream对象。

endl是一个被称为操纵符（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。

作用域运算符（：：）

输入运算符（>>）与输出运算符类似，它接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。与输出运算符类似，输入运算符返回其左侧运算对象作为其计算结果。![img](https://res.weread.qq.com/wrepub/epub_33692196_17)

### 1.3 注释

我们通常需要在调试期间注释掉一些代码。由于这些代码可能包含界定符对形式的注释，因此可能导致注释嵌套错误，因此最好的方式是用单行注释方式注释掉代码段的每一行。![img](https://res.weread.qq.com/wrepub/epub_33692196_26)

### 1.4 控制流

当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。

对于作为函数界定符的花括号，我们习惯将其放在单独一行中。我们还习惯对复合IO表达式设置缩进，以使输入输出运算符排列整齐。

### 1.5 类

习惯上，头文件根据其中定义的类的名字来命名。我们通常使用.h作为头文件的后缀，但也有一些程序员习惯.H、.hpp或.hxx。**标准库头文件通常不带后缀。**编译器一般不关心头文件名的形式，但有的IDE对此有特定要求。

此程序以两个#include指令开始，其中一个使用了新的形式。**包含来自标准库的头文件时，也应该用尖括号（<>）包围头文件名。对于不属于标准库的头文件，则用双引号（" "）包围。**

大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与命名文件关联起来：**$ addItems <infile >outfile**

假定$是操作系统提示符，我们的加法程序已经编译为名为addItems.exe的可执行文件（在UNIX中是addItems），则上述命令会从一个名为infile的文件读取销售记录，并将输出结果写入到一个名为outfile的文件中，两个文件都位于当前目录中。

# 第一部分 C++基础

大多数编程语言通过两种方式来进一步补充其基本特征：一是赋予程序员自定义数据类型的权利，从而实现对语言的扩展；二是将一些有用的功能封装成库函数提供给程序员。

C++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。

## 第二章 变量和基本类型

### 2.1 基本内置类型

C++定义了一套包括**算术类型（arithmetic type）和空类型（void）**在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

**算术类型**分为两类：**整型（integral type，包括字符和布尔类型在内）**和**浮点型**。

算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。表2.1列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。

![img](https://res.weread.qq.com/wrepub/epub_33692196_61)

基本的字符类型是char，一个char的空间应确保可以存放**机器基本字符集**中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。

C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个longlong至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。

大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。

大多数计算机将内存中的每个字节与一个数字（被称为“地址（address）”）关联起来，在一个字节为8比特、字为32比特的机器上，我们可能看到一个字的内存区域如下所示：![img](https://res.weread.qq.com/wrepub/epub_33692196_63)

其中，左侧是字节的地址，右侧是字节中8比特的具体内容。

为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。

浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。

除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。**带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。**

类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long。类型unsigned int可以缩写为unsigned。

字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。**类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。**

C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的signed char理论上应该可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。

#### **如何选择类型**：

和C语言一样，C++的设计准则之一也是尽可能地接近硬件。

- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
- **在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。**因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsignedchar。
- **执行浮点数运算选用double，**这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

#### **类型转换**：

- 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为**0则结果为false**，**否则结果为true**。
- 当我们把一个布尔值赋给非布尔类型时，初始值为**false则结果为0**，初始值为**true则结果为1**。
- 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
-  当我们**赋给无符号类型一个超出它表示范围的值时**，结果是**初始值对无符号类型表示数值总数取模后的余数**。例如，8比特大小的unsigned char可以表示**0至255**区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值**对256取模**后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255**（这个结论有问题，结果是255，但是不是通过取余运算得出的）**
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

当一个算术表达式中**既有无符号数又有int值（有符号）**时，那个**int值（有符号）就会转换成无符号数**。

把负数转换成无符号数类似于直接给无符号数赋一个负值，**结果等于这个负数加上无符号数的模**。2^32-42？？？

**这里要研究一下在补码层面是怎么操作的？**

![img](https://res.weread.qq.com/wrepub/epub_33692196_67)

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：![img](https://res.weread.qq.com/wrepub/epub_33692196_68)

如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如a＊b的式子中，如果a = -1，b = 1，而且a和b都是int，则表达式的值显然为-1。然而，如果a是int，而b是unsigned，则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295。

#### 2.1.3 字面值常量

一个形如42的值被称作字面值常量（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

**整型和浮点型字面值**

以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。**类型short没有对应的字面值。**

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识：![img](https://res.weread.qq.com/wrepub/epub_33692196_74)默认的，浮点型字面值是一个double

**字符和字符串字面值**

字符串字面值的类型实际上是由常量字符构成的数组（array）

编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。

**转义序列**

![img](https://res.weread.qq.com/wrepub/epub_33692196_77)

我们也可以使用泛化的转义序列，其形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。如果反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。例如，"\1234"表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用到后面跟着的所有数字，例如，"\x1234"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。

**指定字面值的类型**

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

![img](https://res.weread.qq.com/wrepub/epub_33692196_82)

![img](https://res.weread.qq.com/wrepub/epub_33692196_84)

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。如果后缀中有U，则该字面值属于无符号类型，也就是说，以U为后缀的十进制数、八进制数或十六进制数都将从unsigned int、unsigned long和unsigned long long中选择能匹配的空间最小的一个作为其数据类型。如果后缀中有L，则字面值的类型至少是long；如果后缀中有LL，则字面值的类型将是long long和unsignedlong long 中的一种。**显然我们可以将U与L或LL合在一起使用。**例如，以UL为后缀的字面值的数据类型将根据具体数值情况或者取unsigned long，或者取unsigned long long。

**布尔字面值和指针字面值**

true和false是布尔类型的字面值，nullptr是指针字面值。

### 2.2 变量

**变量**提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

**对象**是指一块能存储数据并具有某种类型的内存空间。

#### 初始化

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

列表初始化：要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：

![img](https://res.weread.qq.com/wrepub/epub_33692196_92)

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：![img](https://res.weread.qq.com/wrepub/epub_33692196_94)

默认初始化：定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化

定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。

#### 2.2.2　变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separatecompilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。![img](https://res.weread.qq.com/wrepub/epub_33692196_100)

我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：![img](https://res.weread.qq.com/wrepub/epub_33692196_101)

**在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。**

**变量能且只能被定义一次，但是可以被多次声明。**

**变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。**

如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。

### 2.3 复合类型

复合类型（compound type）是指基于其他类型定义的类型：引用和指针。

#### 2.3.1 引用

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。

通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：![img](https://res.weread.qq.com/wrepub/epub_33692196_116)

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此**引用必须初始化**。

**引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。**

因为引用本身不是一个对象，所以不能定义引用的引用。

**引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**

#### 2.3.2 指针

其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成＊d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号＊：![img](https://res.weread.qq.com/wrepub/epub_33692196_126)

指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：![img](https://res.weread.qq.com/wrepub/epub_33692196_127)

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

**指针值：**

1. 指向一个对象。

2. 指向紧邻对象所占空间的下一个位置。

3. 空指针，意味着指针没有指向任何对象。

4. 无效指针，也就是上述情况之外的其他值

**利用指针访问对象**

如果指针指向了一个对象，则允许使用解引用符（操作符＊）来访问该对象：

![img](https://res.weread.qq.com/wrepub/epub_33692196_129)

像&（引用声明，取地址）和＊（指针声明，解引用）这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：

![img](https://res.weread.qq.com/wrepub/epub_33692196_132)

**空指针**

空指针（null pointer）不指向任何对象

![img](https://res.weread.qq.com/wrepub/epub_33692196_133)

把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。

在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。因此**建议初始化所有的指针**，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。**如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。**

给指针赋值就是令它存放一个新的地址，从而指向一个新的对象

赋值永远改变的是等号左侧的对象。

![img](https://res.weread.qq.com/wrepub/epub_33692196_137)

![img](https://res.weread.qq.com/wrepub/epub_33692196_138)

**其他指针操作**

如果指针的值是0，条件取false。任何非0指针对应的条件值都是true。

**指针比较**

对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（！=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。

**void＊ 指针**是一种特殊的指针类型，可用于存放任意对象的地址。一个void＊指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：概括说来，以void＊的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

类型修饰符（*和&）是声明符的一部分：

![img](https://res.weread.qq.com/wrepub/epub_33692196_145)

**指向指针的指针**

通过＊的个数可以区分指针的级别。也就是说，＊＊表示指向指针的指针，＊＊＊表示指向指针的指针的指针

![img](https://res.weread.qq.com/wrepub/epub_33692196_152)

![img](https://res.weread.qq.com/wrepub/epub_33692196_153)

**指向指针的引用**

![img](https://res.weread.qq.com/wrepub/epub_33692196_155)

**int \*&r 可以这么读 int\*& r ，就知道r是什么类型的变量。**

### 2.4 const限定符

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

编译器将在编译过程中把用到该变量的地方都替换成对应的值。为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：![img](https://res.weread.qq.com/wrepub/epub_33692196_163)

file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。

**const引用**

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

**初始化和对const的引用**

![img](https://res.weread.qq.com/wrepub/epub_33692196_169)

![img](https://res.weread.qq.com/wrepub/epub_33692196_170)

**对const的引用可能引用一个并非const的对象**

![img](https://res.weread.qq.com/wrepub/epub_33692196_171)

#### 2.4.2 指针和const

![img](https://res.weread.qq.com/wrepub/epub_33692196_172)

**const 是包括在类型里的，不是声明符，const int是一体**

**const指针**

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：![img](https://res.weread.qq.com/wrepub/epub_33692196_175)

要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是＊，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。

#### 2.4.3 顶层const

指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词**顶层const（top-level const）表示指针本身是个常量**，而用名词**底层const（low-level const）表示指针所指的对象是一个常量**。![img](https://res.weread.qq.com/wrepub/epub_33692196_181)

底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者说两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。（const也是数据类型的一部分）

#### 2.4.4　constexpr和常量表达式

**常量表达式**（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。

![img](https://res.weread.qq.com/wrepub/epub_33692196_186)

![img](https://res.weread.qq.com/wrepub/epub_33692196_187)

尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。

尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。

C++11新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。

函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。

**指针和constexpr**

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：![img](https://res.weread.qq.com/wrepub/epub_33692196_191)

constexpr把它所定义的对象置为了顶层const

constexpr指针既可以指向常量也可以指向一个非常量

### 2.5 处理类型

#### 2.5.1 类型别名

类型别名（type alias）是一个名字，它是某种类型的同义词。

![img](https://res.weread.qq.com/wrepub/epub_33692196_194)

新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：![img](https://res.weread.qq.com/wrepub/epub_33692196_196)

**指针、常量和类型别名**

![img](https://res.weread.qq.com/wrepub/epub_33692196_199)

上述两条声明语句的基本数据类型都是const pstring，和过去一样，**const是对给定类型的修饰**。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。

#### 2.5.2　auto类型说明符

auto一般会忽略掉顶层const，同时底层const则会保留下来。

如果希望推断出的auto类型是一个顶层const，需要明确指出：![img](https://res.weread.qq.com/wrepub/epub_33692196_206)

**符号&和＊只从属于某个声明符，而非基本数据类型的一部分。**

#### 2.5.3　decltype类型指示符

在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

![img](https://res.weread.qq.com/wrepub/epub_33692196_212)

### 2.6 自定义数据结构

![img](https://res.weread.qq.com/wrepub/epub_33692196_219)

#### 2.6.3　编写自己的头文件

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。

头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。

头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。

![img](https://res.weread.qq.com/wrepub/epub_33692196_231)

## 第3章　字符串、向量和数组

string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。还有一种标准库类型是迭代器，它是string和vector的配套类型，常被用于访问string中的字符或vector中的元素。内置数组是一种更基础的类型，string和vector都是对它的某种抽象。

内置类型是由C++语言直接定义的。这些类型，比如数字和字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。

### 3.1　命名空间的using声明



### 3.2　标准库类型string

### 3.3　标准库类型vector

### 3.4　迭代器介绍

### 3.5　数组

### 3.6　多维数组
